package br.com.pdi.visao;

import br.com.pdi.dominio.Imagem;
import br.com.pdi.filtro.FiltroLaplaciano;
import br.com.pdi.filtro.Filtro;
import br.com.pdi.filtro.FiltroMedia;
import br.com.pdi.filtro.FiltroMediana;
import br.com.pdi.servico.HistogramaServico;
import br.com.pdi.monocromatizador.Monocromatizador;
import br.com.pdi.monocromatizador.MonocromatizadorBT709;
import br.com.pdi.monocromatizador.MonocromatizadorBrilho;
import br.com.pdi.monocromatizador.MonocromatizadorComponenteB;
import br.com.pdi.monocromatizador.MonocromatizadorComponenteG;
import br.com.pdi.monocromatizador.MonocromatizadorComponenteR;
import br.com.pdi.monocromatizador.MonocromatizadorMedia;
import br.com.pdi.monocromatizador.MonocromatizadorRmy;
import br.com.pdi.monocromatizador.MonocromatizadorY;
import br.com.pdi.operacao.Operacao;
import java.awt.image.BufferedImage;
import java.beans.PropertyVetoException;
import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JInternalFrame;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;

/*
 * Esta classe é a janela principal do projeto da disciplina Tópicos Especiais em Informática
 * (Processamento de Imagens) da Faculdade de Tecnologia de Mogi das Cruzes - Fatec.
 *
 * INSTRUÇÕES PARA O ALUNO:
 *  - Você deverá incluir itens de menu na barra de menus desta janela e implementar o tratamento
 *    de eventos para eles.
 *    O que o evento deverá fazer? Implementar alguma técnica de processamento de imagens, como
 *    a operação aritmética de adição.
 * 
 *    Na implementação das técnicas, você precisará recuperar a imagem atualmente selecionada
 *    ou mesmo solicitar ao usuário a seleção de algumas imagens. Para tanto, veja as opções seguintes:
 *    > Para recuperar a imagem atualmente selecionada, utilize o método getImagemSelecionada().
 *    > Para exibir uma caixa de seleção de imagens (utilizada para operações que necessitam de mais
 *    de uma imagem, como as operações aritméticas), utilize o método selecionarImagens(). Este método
 *    retorna uma array com as imagens selecionadas.
 * 
 *  Um exemplo de implementação de evento está disponível nos itens de menu "Exemplo 1" e
 *  "Exemplo 2". Os utilize para entender como se manipula uma imagem (como se recupera informações
 *  sobre seus pixels e como se desenha uma nova cor para os pixels).
 * 
 * @author Leandro Luque (Professor) - leandro.luque@gmail.com
 * @version 1.0
 * Created on 02/03/2012, 21:25:48
 */
public class Desktop extends javax.swing.JFrame {

    // Diretório onde o último arquivo de imagem foi aberto. Inicialmente nenhum diretório
    // está selecionado.
    // Utilizado para agilizar o processo de abertura de arquivos.
    private File ultimoDiretorioUtilizado = null;

    // Utilizado na nomeação das imagens criadas (você pode usar se quiser).
    // Veja os exemplos já citados na documentação da classe.
    private static int contador = 1;
    
    private final int R = 0;
    private final int G = 1;
    private final int B = 2;

    /**
     * Creates new form Desktop
     */
    public Desktop() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        desPanDesktop = new javax.swing.JDesktopPane();
        menBarMenuPrincipal = new javax.swing.JMenuBar();
        menArquivo = new javax.swing.JMenu();
        menIteAbrir = new javax.swing.JMenuItem();
        menIteSalvarComo = new javax.swing.JMenuItem();
        sepArquivo1 = new javax.swing.JPopupMenu.Separator();
        menIteSair = new javax.swing.JMenuItem();
        menExemplo = new javax.swing.JMenu();
        menIteExemplo1 = new javax.swing.JMenuItem();
        menIteExemplo2 = new javax.swing.JMenuItem();
        menOperacoesAritmeticas = new javax.swing.JMenu();
        menIteSoma = new javax.swing.JMenuItem();
        menIteSubtracao = new javax.swing.JMenuItem();
        menIteMultiplicacao = new javax.swing.JMenuItem();
        menIteDivisao = new javax.swing.JMenuItem();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        RemoverRuido = new javax.swing.JMenuItem();
        MostrarBordas = new javax.swing.JMenuItem();
        blur = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        ConversaoDeCores = new javax.swing.JMenu();
        MonocromatizarPorComponente = new javax.swing.JMenu();
        ComponenteR = new javax.swing.JMenuItem();
        ComponenteG = new javax.swing.JMenuItem();
        ComponenteB = new javax.swing.JMenuItem();
        MonocromatizarPorBrilho = new javax.swing.JMenuItem();
        MonocromatizarPorMedia = new javax.swing.JMenuItem();
        MonocromatizarPorLuminosidade = new javax.swing.JMenu();
        BT709Grayscale = new javax.swing.JMenuItem();
        RMYGrayscale = new javax.swing.JMenuItem();
        YGrayscale = new javax.swing.JMenuItem();
        Histograma = new javax.swing.JMenu();
        Exibir = new javax.swing.JMenuItem();
        equalizar = new javax.swing.JMenuItem();
        limiarizacao = new javax.swing.JMenu();
        limiarizacaoManual = new javax.swing.JMenuItem();
        LimiarizacaoGlobalAutomatica = new javax.swing.JMenuItem();
        LimiarizacaoLocalAutomatica = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Projeto da Disciplina \"Tópicos Especiais em Informática\" - Prof. Leandro Luque - Fatec Mogi das Cruzes");

        menArquivo.setMnemonic('A');
        menArquivo.setText("Arquivo");

        menIteAbrir.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.CTRL_MASK));
        menIteAbrir.setMnemonic('A');
        menIteAbrir.setText("Abrir imagem");
        menIteAbrir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteAbrirActionPerformed(evt);
            }
        });
        menArquivo.add(menIteAbrir);
        menIteAbrir.getAccessibleContext().setAccessibleDescription("Abre uma nova imagem");

        menIteSalvarComo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        menIteSalvarComo.setMnemonic('S');
        menIteSalvarComo.setText("Salvar imagem como");
        menIteSalvarComo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteSalvarComoActionPerformed(evt);
            }
        });
        menArquivo.add(menIteSalvarComo);
        menArquivo.add(sepArquivo1);

        menIteSair.setMnemonic('S');
        menIteSair.setText("Sair");
        menIteSair.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteSairActionPerformed(evt);
            }
        });
        menArquivo.add(menIteSair);

        menBarMenuPrincipal.add(menArquivo);

        menExemplo.setMnemonic('E');
        menExemplo.setText("Exemplo");

        menIteExemplo1.setMnemonic('1');
        menIteExemplo1.setText("Exemplo 1");
        menIteExemplo1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteExemplo1ActionPerformed(evt);
            }
        });
        menExemplo.add(menIteExemplo1);

        menIteExemplo2.setMnemonic('2');
        menIteExemplo2.setText("Exemplo 2");
        menIteExemplo2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteExemplo2ActionPerformed(evt);
            }
        });
        menExemplo.add(menIteExemplo2);

        menBarMenuPrincipal.add(menExemplo);

        menOperacoesAritmeticas.setMnemonic('O');
        menOperacoesAritmeticas.setText("Operações Aritméticas");

        menIteSoma.setMnemonic('S');
        menIteSoma.setText("Soma");
        menIteSoma.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteSomaActionPerformed(evt);
            }
        });
        menOperacoesAritmeticas.add(menIteSoma);

        menIteSubtracao.setMnemonic('u');
        menIteSubtracao.setText("Subtração");
        menIteSubtracao.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteSubtracaoActionPerformed(evt);
            }
        });
        menOperacoesAritmeticas.add(menIteSubtracao);

        menIteMultiplicacao.setMnemonic('M');
        menIteMultiplicacao.setText("Multiplicação");
        menIteMultiplicacao.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteMultiplicacaoActionPerformed(evt);
            }
        });
        menOperacoesAritmeticas.add(menIteMultiplicacao);

        menIteDivisao.setMnemonic('D');
        menIteDivisao.setText("Média");
        menIteDivisao.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menIteDivisaoActionPerformed(evt);
            }
        });
        menOperacoesAritmeticas.add(menIteDivisao);

        menBarMenuPrincipal.add(menOperacoesAritmeticas);

        jMenu1.setText("Outras Operações");

        jMenuItem1.setText("Encontrar diferenças");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        jMenuItem2.setText("Normalizar a imagem atual");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem2);

        RemoverRuido.setText("Remover Ruído");
        RemoverRuido.setActionCommand("Remover Ruido");
        RemoverRuido.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RemoverRuidoActionPerformed(evt);
            }
        });
        jMenu1.add(RemoverRuido);

        MostrarBordas.setText("Mostrar Bordas");
        MostrarBordas.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MostrarBordasActionPerformed(evt);
            }
        });
        jMenu1.add(MostrarBordas);

        blur.setText("Blur");
        blur.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                blurActionPerformed(evt);
            }
        });
        jMenu1.add(blur);
        blur.getAccessibleContext().setAccessibleDescription("");

        menBarMenuPrincipal.add(jMenu1);
        menBarMenuPrincipal.add(jMenu2);

        ConversaoDeCores.setText("Conversão de Cores");
        ConversaoDeCores.setToolTipText("");

        MonocromatizarPorComponente.setText("Monocromatizar por Componente");

        ComponenteR.setText("R");
        ComponenteR.setToolTipText("");
        ComponenteR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ComponenteRActionPerformed(evt);
            }
        });
        MonocromatizarPorComponente.add(ComponenteR);

        ComponenteG.setText("G");
        ComponenteG.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ComponenteGActionPerformed(evt);
            }
        });
        MonocromatizarPorComponente.add(ComponenteG);

        ComponenteB.setText("B");
        ComponenteB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ComponenteBActionPerformed(evt);
            }
        });
        MonocromatizarPorComponente.add(ComponenteB);

        ConversaoDeCores.add(MonocromatizarPorComponente);

        MonocromatizarPorBrilho.setText("Monocromatizar por Brilho");
        MonocromatizarPorBrilho.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MonocromatizarPorBrilhoActionPerformed(evt);
            }
        });
        ConversaoDeCores.add(MonocromatizarPorBrilho);

        MonocromatizarPorMedia.setText("Monocromatizar por Média");
        MonocromatizarPorMedia.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MonocromatizarPorMediaActionPerformed(evt);
            }
        });
        ConversaoDeCores.add(MonocromatizarPorMedia);

        MonocromatizarPorLuminosidade.setText("Monocromatizar por Luminosidade");

        BT709Grayscale.setText("BT709 Grayscale");
        BT709Grayscale.setToolTipText("");
        BT709Grayscale.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BT709GrayscaleActionPerformed(evt);
            }
        });
        MonocromatizarPorLuminosidade.add(BT709Grayscale);

        RMYGrayscale.setText("RMY Grayscale");
        RMYGrayscale.setToolTipText("");
        RMYGrayscale.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RMYGrayscaleActionPerformed(evt);
            }
        });
        MonocromatizarPorLuminosidade.add(RMYGrayscale);

        YGrayscale.setText("Y-Grayscale");
        YGrayscale.setToolTipText("");
        YGrayscale.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YGrayscaleActionPerformed(evt);
            }
        });
        MonocromatizarPorLuminosidade.add(YGrayscale);

        ConversaoDeCores.add(MonocromatizarPorLuminosidade);

        menBarMenuPrincipal.add(ConversaoDeCores);

        Histograma.setText("Histograma");

        Exibir.setText("Exibir");
        Exibir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExibirActionPerformed(evt);
            }
        });
        Histograma.add(Exibir);

        equalizar.setText("Equalizar");
        equalizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                equalizarActionPerformed(evt);
            }
        });
        Histograma.add(equalizar);

        menBarMenuPrincipal.add(Histograma);

        limiarizacao.setText("Limiarização");

        limiarizacaoManual.setText("Limiarização Manual");
        limiarizacaoManual.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                limiarizacaoManualActionPerformed(evt);
            }
        });
        limiarizacao.add(limiarizacaoManual);

        LimiarizacaoGlobalAutomatica.setText("Limiarização Global Automática");
        LimiarizacaoGlobalAutomatica.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LimiarizacaoGlobalAutomaticaActionPerformed(evt);
            }
        });
        limiarizacao.add(LimiarizacaoGlobalAutomatica);

        LimiarizacaoLocalAutomatica.setText("Limiarização Local Automática");
        LimiarizacaoLocalAutomatica.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LimiarizacaoLocalAutomaticaActionPerformed(evt);
            }
        });
        limiarizacao.add(LimiarizacaoLocalAutomatica);

        menBarMenuPrincipal.add(limiarizacao);

        setJMenuBar(menBarMenuPrincipal);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(desPanDesktop, javax.swing.GroupLayout.DEFAULT_SIZE, 705, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(desPanDesktop, javax.swing.GroupLayout.DEFAULT_SIZE, 414, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    //*******************************************
    // Abre uma nova imagem.
    private void menIteAbrirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteAbrirActionPerformed
        // Exibe uma janela para a seleção de arquivos.
        JFileChooser selecionadorArquivo = new JFileChooser(ultimoDiretorioUtilizado);
        selecionadorArquivo.setMultiSelectionEnabled(true);
        // Se o usuário selecionou algum arquivo.
        if (selecionadorArquivo.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            // Para cada arquivo selecionado.
            for (File arquivo : selecionadorArquivo.getSelectedFiles()) {
                // Cria uma nova imagem para armazenar o arquivo.
                BufferedImage imagemLida = null;
                try {
                    imagemLida = ImageIO.read(arquivo);
                } catch (IOException erro) {
                    JOptionPane.showMessageDialog(rootPane, "Ocorreu um erro ao abrir o arquivo " + selecionadorArquivo.getSelectedFile().getName() + ".\nMensagem de erro: " + erro.getMessage() + ".");
                    return;
                }
                ImagemGUI imagem = new ImagemGUI(selecionadorArquivo.getSelectedFile().getAbsolutePath(), imagemLida);

                // Exibe a imagem em uma nova janela.
                adicionarImagem(imagem);
            }
            // Armazena o diretório utilizado.
            ultimoDiretorioUtilizado = selecionadorArquivo.getCurrentDirectory();
        }
    }//GEN-LAST:event_menIteAbrirActionPerformed

    // Fecha a aplicação.
    private void menIteSairActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteSairActionPerformed
        dispose();
    }//GEN-LAST:event_menIteSairActionPerformed

    //*******************************************
    // Evento de tratamento da operação de soma.
    private void menIteSomaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteSomaActionPerformed
        // Solicita ao usuário selecionar ao  menos duas (2) imagens.
        ImagemGUI[] imagens = selecionarImagens(2);

        // Se o usuário cancelou a operação.
        if (imagens == null) {
            return;
        }

        realizarOperacao(imagens, (a, b) -> a + b, false);
    }//GEN-LAST:event_menIteSomaActionPerformed

    // Evento de tratamento da operação de subtração.
    private void menIteSubtracaoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteSubtracaoActionPerformed
        // Solicita ao usuário selecionar ao  menos duas (2) imagens.
        ImagemGUI[] imagens = selecionarImagens(2);

        // Se o usuário cancelou a operação.
        if (imagens == null) {
            return;
        }

        realizarOperacao(imagens, (a, b) -> a - b, true);
    }//GEN-LAST:event_menIteSubtracaoActionPerformed

    // Evento de tratamento da operação de multiplicação.
    private void menIteMultiplicacaoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteMultiplicacaoActionPerformed
        // Solicita ao usuário selecionar ao  menos duas (2) imagens.
        ImagemGUI[] imagens = selecionarImagens(2);

        // Se o usuário cancelou a operação.
        if (imagens == null) {
            return;
        }

        // Realiza multiplicação das imagens
        int [][][] resultado = realizarOperacao(imagens, (a, b) -> a * b, true);
        
        // Gera imagem Truncada
        ImagemGUI truncada = truncar(resultado);
        // Gera imagem Normalizada
        ImagemGUI normalizada = normalizar(resultado);
        
        adicionarImagem(truncada);
        adicionarImagem(normalizada);
    }//GEN-LAST:event_menIteMultiplicacaoActionPerformed

    // Evento de tratamento da operação de divisão.
    private void menIteDivisaoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteDivisaoActionPerformed
        // Solicita ao usuário selecionar ao  menos duas (2) imagens.
        ImagemGUI[] imagens = selecionarImagens(2);

        // Se o usuário cancelou a operação.
        if (imagens == null) {
            return;
        }

        // Realiza soma das imagens
        int [][][] resultado = realizarOperacao(imagens, (a, b) -> a + b, true);
        int [][][][] result = new int[1][][][];
        result[0] = resultado;
        // Realiza divisão pela quantidade de imagens
        int [][][] resultado2 = realizarOperacao(result, (a, b) -> b / imagens.length, false);
        
        // Gera imagem Normalizada
        ImagemGUI normalizada = normalizar(resultado2);

        // Pintar o resultado na imagem final.
        adicionarImagem(normalizada);
    }//GEN-LAST:event_menIteDivisaoActionPerformed

    // Neste exemplo, a imagem atualmente selecionada é recuperada e o centro dela é
    // pintado de verde. Perceba que a imagem não foi alterada, uma nova foi criada.
    private void menIteExemplo1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteExemplo1ActionPerformed
        // Verifica se existe alguma imagem selecionada.
        if (getImagemSelecionada() == null) {
            JOptionPane.showMessageDialog(this, "Nenhuma imagem está selecionada. Selecione alguma e depois clique nesta opção novamente.");
            return;
        }

        // Recupera a imagem atualmente selecionada.
        ImagemGUI imagem = getImagemSelecionada();
        // Cria uma nova imagem baseada na selecionada.
        ImagemGUI novaImagem = new ImagemGUI("Nova imagem com centro verde " + (contador++), imagem);

        // Recupera o centro da imagem.
        int xCentro = novaImagem.getLargura() / 2;
        int yCentro = novaImagem.getAltura() / 2;
        // Calcula uma área relativa ao tamanho da imagem para ser pintada.
        int deltaX = novaImagem.getLargura() / 4;
        int deltaY = novaImagem.getAltura() / 4;
        // Pinta os pixels do centro da imagem de verde.               
        for (int x = xCentro - deltaX; x <= xCentro + deltaX; x++) {
            for (int y = yCentro - deltaY; y <= yCentro + deltaY; y++) {
                novaImagem.setRGB(x, y, 0, 255, 0);
            }
        }

        // Exibe a imagem criada.
        adicionarImagem(novaImagem);
    }//GEN-LAST:event_menIteExemplo1ActionPerformed

    // Salva a imagem selecionada em um arquivo.
    private void menIteSalvarComoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteSalvarComoActionPerformed
        // Exibe uma janela para a escolha do nome do arquivo.
        JFileChooser selecionadorArquivo = new JFileChooser(ultimoDiretorioUtilizado);
        // Adiciona a extensão JPEG.
        selecionadorArquivo.addChoosableFileFilter(new FileFilter() {
            @Override
            public String getDescription() {
                return "JPEG";
            }

            @Override
            public boolean accept(File arquivo) {
                if (arquivo == null) {
                    return false;
                }
                if (arquivo.isDirectory()) {
                    return true;
                }
                return arquivo.getName().toLowerCase().endsWith("jpg");
            }
        });
        // Adiciona a extensão PNG.
        selecionadorArquivo.addChoosableFileFilter(new FileFilter() {
            @Override
            public String getDescription() {
                return "PNG";
            }

            @Override
            public boolean accept(File arquivo) {
                if (arquivo == null) {
                    return false;
                }
                if (arquivo.isDirectory()) {
                    return true;
                }
                return arquivo.getName().toLowerCase().endsWith("png");
            }
        });
        // Adiciona a extensão GIF.
        selecionadorArquivo.addChoosableFileFilter(new FileFilter() {
            @Override
            public String getDescription() {
                return "GIF";
            }

            @Override
            public boolean accept(File arquivo) {
                if (arquivo == null) {
                    return false;
                }
                if (arquivo.isDirectory()) {
                    return true;
                }
                return arquivo.getName().toLowerCase().endsWith("gif");
            }
        });
        // Se o usuário selecionou algum arquivo.
        if (selecionadorArquivo.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            // Existe um "bug" no Windows 7 que, caso o usuário selecione uma biblioteca (Imagens etc.),
            // uma referência inválida para o sistema de arquivos é retornada.
            // Por isso, o try catch seguinte avalia este erro.
            try {
                selecionadorArquivo.getSelectedFile().getCanonicalFile();
            } catch (IOException erro) {
                JOptionPane.showMessageDialog(this, "Por favor, selecione outra pasta. A pasta selecionada retornou uma referência inválida pelo Sistema Operacional.\nEste é um problema comum no Windows 7 quando você seleciona uma Biblioteca (Imagens, Músicas etc.)");
                return;
            }

            try {
                String nomeArquivo = selecionadorArquivo.getSelectedFile().getAbsolutePath();
                if (selecionadorArquivo.getFileFilter().getDescription().equals("GIF")) {
                    if (!nomeArquivo.toLowerCase().endsWith(".gif")) {
                        nomeArquivo += ".gif";
                    }
                    File arquivo = new File(nomeArquivo);
                    ImageIO.write(getImagemSelecionada().getImagem(), "GIF", arquivo);
                } else if (selecionadorArquivo.getFileFilter().getDescription().equals("PNG")) {
                    if (!nomeArquivo.toLowerCase().endsWith(".png")) {
                        nomeArquivo += ".png";
                    }
                    File arquivo = new File(nomeArquivo);
                    ImageIO.write(getImagemSelecionada().getImagem(), "PNG", arquivo);
                } // JPEG é a extensão padrão.
                else {
                    if (!nomeArquivo.toLowerCase().endsWith(".jpg")) {
                        nomeArquivo += ".jpg";
                    }
                    File arquivo = new File(nomeArquivo);
                    ImageIO.write(getImagemSelecionada().getImagem(), "JPEG", arquivo);
                }
                // Altera o nome da janela.
                getImagemSelecionada().getJanela().setTitle(nomeArquivo);
            } catch (IOException erro) {
                JOptionPane.showMessageDialog(this, "Ocorreu um erro ao gravar o arquivo " + selecionadorArquivo.getSelectedFile().getName() + ".\nMensagem de erro: " + erro.getMessage() + ".");
                return;
            }
            // Armazena o diretório utilizado.
            ultimoDiretorioUtilizado = selecionadorArquivo.getCurrentDirectory();
        }
    }//GEN-LAST:event_menIteSalvarComoActionPerformed

    // Neste exemplo, é exibida uma caixa para seleção de imagens.
    // Para as imagens selecionadas, cria novas imagens com uma mistura delas.
    // Perceba que a imagem não foi alterada, uma nova foi criada.    
    private void menIteExemplo2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menIteExemplo2ActionPerformed
        // Solicita ao usuário selecionar ao  menos duas (2) imagens.
        ImagemGUI[] imagens = selecionarImagens(2);

        // Se o usuário cancelou a operação.
        if (imagens == null) {
            return;
        }

        // Passa por todas as imagens
        for (int i = 0; i < imagens.length - 1; i++) {
            // Cria uma nova imagem baseando-se na atual.
            ImagemGUI nova = new ImagemGUI("Imagem criada com a mistura de outras duas " + (contador++), imagens[i]);
            // Calcula a posição central da imagem atual.
            int meioX = nova.getLargura() / 2;
            int meioY = nova.getAltura() / 2;
            // Copia uma parte da próxima imagem e insere nesta.
            for (int x = 0; x < meioX && x < imagens[i + 1].getLargura(); x++) {
                for (int y = 0; y < meioY && y < imagens[i + 1].getAltura(); y++) {
                    // Recupera os valores de R, G e B do pixel (x,y) da imagem imagens[i+1].
                    int r = imagens[i + 1].getR(x, y);
                    int g = imagens[i + 1].getG(x, y);
                    int b = imagens[i + 1].getB(x, y);
                    // Pinta o pixel (x,y) da imagem imagens[i] com o valor de r, g e b especificados.
                    nova.setRGB(x, y, r, g, b);
                }
            }
            adicionarImagem(nova);
        }
    }//GEN-LAST:event_menIteExemplo2ActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        JOptionPane.showMessageDialog(null, "Ishi! Vai demorar um pouco, hein! Ao final, você verá retângulos envolvendo as regiões de diferença.");

        // Solicita ao usuário selecionar ao  menos duas (2) imagens.
        ImagemGUI[] imagens = selecionarImagens(2);

        // Se o usuário cancelou a operação.
        if (imagens == null) {
            return;
        }

        // Encontrar o tamanho da maior imagem.
        int largura = Integer.MAX_VALUE;
        int altura = Integer.MAX_VALUE;
        for (ImagemGUI imagem : imagens) {
            if (imagem.getLargura() < largura) {
                largura = imagem.getLargura();
            }
            if (imagem.getAltura() < altura) {
                altura = imagem.getAltura();
            }
        }

        // Criar uma matriz para armazenar o resultado da soma.
        int[][] resultadoOperacaoR = new int[altura][largura];
        int[][] resultadoOperacaoG = new int[altura][largura];
        int[][] resultadoOperacaoB = new int[altura][largura];

        int maiorR = Integer.MIN_VALUE;
        int menorR = Integer.MAX_VALUE;
        int maiorG = Integer.MIN_VALUE;
        int menorG = Integer.MAX_VALUE;
        int maiorB = Integer.MIN_VALUE;
        int menorB = Integer.MAX_VALUE;

        // Realiza a subtração.
        for (int x = 0; x < largura; x++) {
            for (int y = 0; y < altura; y++) {
                // Somar os valores dos pixels e armazenar na matriz.
                resultadoOperacaoR[y][x] = imagens[0].getR(x, y) - imagens[1].getR(x, y);
                resultadoOperacaoG[y][x] = imagens[0].getG(x, y) - imagens[1].getG(x, y);
                resultadoOperacaoB[y][x] = imagens[0].getB(x, y) - imagens[1].getB(x, y);

                // Encontra os maiores e menores valores da cada matriz.
                if (resultadoOperacaoR[y][x] > maiorR) {
                    maiorR = resultadoOperacaoR[y][x];
                } else if (resultadoOperacaoR[y][x] < menorR) {
                    menorR = resultadoOperacaoR[y][x];
                }
                if (resultadoOperacaoG[y][x] > maiorG) {
                    maiorG = resultadoOperacaoG[y][x];
                } else if (resultadoOperacaoG[y][x] < menorG) {
                    menorG = resultadoOperacaoG[y][x];
                }
                if (resultadoOperacaoB[y][x] > maiorB) {
                    maiorB = resultadoOperacaoB[y][x];
                } else if (resultadoOperacaoB[y][x] < menorB) {
                    menorB = resultadoOperacaoB[y][x];
                }
            }
        }

        // Cria uma nova imagem baseando-se na atual.
        ImagemGUI truncada = new ImagemGUI("Imagem resultante da operacao com truncamento", largura, altura);
        ImagemGUI normalizada = new ImagemGUI("Imagem resultante da operacao com normalização", largura, altura);

        double fatorR = 255d / (maiorR - menorR);
        double fatorG = 255d / (maiorG - menorG);
        double fatorB = 255d / (maiorB - menorB);

        // Truncar e normalizar.
        for (int x = 0; x < largura; x++) {
            for (int y = 0; y < altura; y++) {
                int r, g, b;
                r = resultadoOperacaoR[y][x];
                g = resultadoOperacaoG[y][x];
                b = resultadoOperacaoB[y][x];

                if (r > 255) {
                    r = 255;
                } else if (r < 0) {
                    r = 0;
                }

                if (g > 255) {
                    g = 255;
                } else if (g < 0) {
                    g = 0;
                }

                if (b > 255) {
                    b = 255;
                } else if (b < 0) {
                    b = 0;
                }

                truncada.setRGB(x, y, r, g, b);

                r = (int) (fatorR * (resultadoOperacaoR[y][x] - menorR));
                g = (int) (fatorG * (resultadoOperacaoG[y][x] - menorG));
                b = (int) (fatorB * (resultadoOperacaoB[y][x] - menorB));

                normalizada.setRGB(x, y, r, g, b);
            }
        }

        // Pintar o resultado na imagem final.
        //adicionarImagem(truncada);
        //adicionarImagem(normalizada);
        int[] corMaisFrequente = encontrarCorMaisFrequente(normalizada);

        ImagemGUI normalizadaComFundoIdentificado = new ImagemGUI("Imagem resultante da operacao com normalização, com fundo identificado", normalizada);

        int delta = 10;
        for (int x = 0; x < normalizada.getLargura(); x++) {
            for (int y = 0; y < normalizada.getAltura(); y++) {
                if (normalizada.getR(x, y) > corMaisFrequente[0] - delta && normalizada.getR(x, y) < corMaisFrequente[0] + delta
                        && normalizada.getG(x, y) > corMaisFrequente[1] - delta
                        && normalizada.getG(x, y) < corMaisFrequente[1] + delta
                        && normalizada.getB(x, y) > corMaisFrequente[2] - delta
                        && normalizada.getB(x, y) < corMaisFrequente[2] + delta) {
                    normalizadaComFundoIdentificado.setRGB(x, y, 0, 0, 0);
                }
            }
        }
        //adicionarImagem(normalizadaComFundoIdentificado);

        ImagemGUI comRegioesIdentificadas = new ImagemGUI("Imagem com regiões identificadas", largura, altura);

        boolean[][] jaVisitados = new boolean[normalizadaComFundoIdentificado.getAltura()][normalizadaComFundoIdentificado.getLargura()];

        // Usar algoritmo de Flood-Fill para identificar regiões.
        for (int x = 0; x < normalizadaComFundoIdentificado.getLargura(); x++) {
            for (int y = 0; y < normalizadaComFundoIdentificado.getAltura(); y++) {
                if (normalizadaComFundoIdentificado.getR(x, y) != 0
                        && normalizadaComFundoIdentificado.getG(x, y) != 0
                        && normalizadaComFundoIdentificado.getB(x, y) != 0
                        && !jaVisitados[y][x]) {

                    //     List<int[]> pixelsDoConjunto = new ArrayList<int[]>();
                    Stack<int[]> aVisitar = new Stack<>();

                    int corRAleatoria = (int) (255 * Math.random());
                    int corGAleatoria = (int) (255 * Math.random());
                    int corBAleatoria = (int) (255 * Math.random());

                    int menorX = Integer.MAX_VALUE;
                    int menorY = Integer.MAX_VALUE;
                    int maiorX = Integer.MIN_VALUE;
                    int maiorY = Integer.MIN_VALUE;

                    aVisitar.push(new int[]{x, y});
                    while (!aVisitar.isEmpty()) {

                        int[] pixelAVisitar = aVisitar.pop();
                        int pixelX = pixelAVisitar[0];
                        int pixelY = pixelAVisitar[1];
                        jaVisitados[pixelY][pixelX] = true;

                        if (pixelX < menorX) {
                            menorX = pixelX;
                        }
                        if (pixelX > maiorX) {
                            maiorX = pixelX;
                        }
                        if (pixelY < menorY) {
                            menorY = pixelY;
                        }
                        if (pixelY > maiorY) {
                            maiorY = pixelY;
                        }

                        //    pixelsDoConjunto.add(pixelAVisitar);
                        //   comRegioesIdentificadas.setRGB(pixelX, pixelY, corRAleatoria, corGAleatoria, corBAleatoria);
                        for (int deltaX = -10; deltaX <= 10; deltaX++) {
                            for (int deltaY = -10; deltaY <= 10; deltaY++) {
                                if (normalizadaComFundoIdentificado.getR(pixelX + deltaX, pixelY + deltaY) != 0
                                        && normalizadaComFundoIdentificado.getG(pixelX + deltaX, pixelY + deltaY) != 0
                                        && normalizadaComFundoIdentificado.getB(pixelX + deltaX, pixelY + deltaY) != 0
                                        && !jaVisitados[pixelY + deltaY][pixelX + deltaX]) {
                                    aVisitar.push(new int[]{pixelX + deltaX, pixelY + deltaY});
                                }
                            }
                        }

                    } // Fim do processamento da pilha.

                    // Desenha um retângulo em torno da região de diferença.
                    for (int xAtual = menorX; xAtual <= maiorX; xAtual++) {
                        for (int yAtual = menorY; yAtual <= maiorY; yAtual++) {
                            comRegioesIdentificadas.setRGB(xAtual, Math.max(0, menorY - 1), corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(xAtual, menorY, corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(xAtual, Math.min(maiorY, altura - 1), corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(xAtual, maiorY, corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(menorX, yAtual, corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(Math.max(menorX, 0), yAtual, corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(maiorX, yAtual, corRAleatoria, corGAleatoria, corBAleatoria);
                            comRegioesIdentificadas.setRGB(Math.min(maiorX, largura - 1), yAtual, corRAleatoria, corGAleatoria, corBAleatoria);
                        }
                    }

                }
            }
        }

        adicionarImagem(comRegioesIdentificadas);
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }

        // Cria uma nova imagem baseando-se na atual.
        ImagemGUI normalizada = new ImagemGUI("Imagem resultante da operacao com normalização", imagem);

        normalizada = normalizar(normalizada.getMatrizesRGB());

        // Pintar o resultado na imagem final.
        adicionarImagem(normalizada);
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void RemoverRuidoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RemoverRuidoActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        int[][] kernel = new int[3][3];
        
        int[][][] cores = aplicarKernel(kernel, imagem, new FiltroMediana());
        
        ImagemGUI imagemFiltrada = normalizar(cores);
        
        adicionarImagem(imagemFiltrada);
    }//GEN-LAST:event_RemoverRuidoActionPerformed

    private void MostrarBordasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MostrarBordasActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        int[][] kernel = {{-1,-1,-1},{-1,8,-1},{-1,-1,-1}};
        
        int[][][] cores = aplicarKernel(kernel, imagem, new FiltroLaplaciano());
        
        ImagemGUI imagemFiltrada = normalizar(cores);
        
        adicionarImagem(imagemFiltrada);
    }//GEN-LAST:event_MostrarBordasActionPerformed

    private void blurActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_blurActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        int[][] kernel = new int[5][5];
        
        int[][][] cores = aplicarKernelBorda(kernel, imagem, new FiltroMedia());
        
        ImagemGUI imagemFiltrada = truncar(cores);
        adicionarImagem(imagemFiltrada);
    }//GEN-LAST:event_blurActionPerformed

    private void ComponenteRActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ComponenteRActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorComponenteR());
        imagemMonocromatica.setNome("Componente R");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_ComponenteRActionPerformed

    private void ComponenteGActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ComponenteGActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorComponenteG());
        imagemMonocromatica.setNome("Componente G");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_ComponenteGActionPerformed

    private void ComponenteBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ComponenteBActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorComponenteB());
        imagemMonocromatica.setNome("Componente B");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_ComponenteBActionPerformed

    private void MonocromatizarPorBrilhoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MonocromatizarPorBrilhoActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorBrilho());
        imagemMonocromatica.setNome("Brilho");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_MonocromatizarPorBrilhoActionPerformed

    private void MonocromatizarPorMediaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MonocromatizarPorMediaActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorMedia());
        imagemMonocromatica.setNome("Média");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_MonocromatizarPorMediaActionPerformed

    private void BT709GrayscaleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BT709GrayscaleActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorBT709());
        imagemMonocromatica.setNome("BT709 Grayscale");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_BT709GrayscaleActionPerformed

    private void RMYGrayscaleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RMYGrayscaleActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorRmy());
        imagemMonocromatica.setNome("RMY Grayscale");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_RMYGrayscaleActionPerformed

    private void YGrayscaleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YGrayscaleActionPerformed
        ImagemGUI imagem = getImagemSelecionada();

        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorY());
        imagemMonocromatica.setNome("Y-Grayscale");
        adicionarImagem(imagemMonocromatica);
    }//GEN-LAST:event_YGrayscaleActionPerformed

    private void ExibirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExibirActionPerformed
        ImagemGUI imagem = getImagemSelecionada();
        
        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemMonocromatica = monocromatizar(imagem, new MonocromatizadorY());
        ImagemGUI histograma = gerarHistograma(imagemMonocromatica);
        adicionarImagem(histograma);
    }//GEN-LAST:event_ExibirActionPerformed

    private void equalizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_equalizarActionPerformed
        ImagemGUI imagem = getImagemSelecionada();
        
        if (null == imagem) {
            return;
        }
        
        ImagemGUI imagemEqualizada = equalizar(imagem);
        adicionarImagem(imagemEqualizada);
    }//GEN-LAST:event_equalizarActionPerformed

    private void limiarizacaoManualActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_limiarizacaoManualActionPerformed
        ImagemGUI imagem = getImagemSelecionada();
        
        if (null == imagem) {
            return;
        }
        int limiar = - 1;
        
        do {
            String valor = JOptionPane
                    .showInputDialog(null, "Digite o limiar", "Limiarização", JOptionPane.QUESTION_MESSAGE);
            try {
                limiar = Integer.valueOf(valor);
            } catch (NumberFormatException e) {
                JOptionPane
                    .showMessageDialog(null, "Valor inválido", "Limiarização", JOptionPane.WARNING_MESSAGE);
            }
        } while (limiar < 0 || limiar > 255);
        
        int x1, x2, y1, y2;
        x1 = y1 = 0;
        x2 = imagem.getLargura();
        y2 = imagem.getAltura();
        
        ImagemGUI imagemLimiarizada = new ImagemGUI(x2, y2);
        
        limiarizar(imagem, imagemLimiarizada, x1, x2, y1, y2, limiar);
        imagemLimiarizada.setNome("Limiarização Manual");
        adicionarImagem(imagemLimiarizada);
    }//GEN-LAST:event_limiarizacaoManualActionPerformed

    private void LimiarizacaoGlobalAutomaticaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LimiarizacaoGlobalAutomaticaActionPerformed
        ImagemGUI imagem = getImagemSelecionada();
        if (null == imagem) {
            return;
        }   int x1, x2, y1, y2;
        x1 = y1 = 0;
        x2 = imagem.getLargura();
        y2 = imagem.getAltura();
        ImagemGUI imagemLimiarizada = new ImagemGUI(x2, y2);
        
        limiarizar(imagem, imagemLimiarizada, x1, x2, y1, y2);
        imagemLimiarizada.setNome("Limiarização Global");
        adicionarImagem(imagemLimiarizada);
    }//GEN-LAST:event_LimiarizacaoGlobalAutomaticaActionPerformed

    private void LimiarizacaoLocalAutomaticaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LimiarizacaoLocalAutomaticaActionPerformed
        ImagemGUI imagem = getImagemSelecionada();
        
        if (null == imagem) {
            return;
        }
        
        int altura = imagem.getAltura();
        int largura = imagem.getLargura();
        
        int linhas = 0, colunas = 0;
        
        do {
            String valor = JOptionPane
                    .showInputDialog(null, "Digite a quantidade de frames para a largura da imagem", "Limiarização", JOptionPane.QUESTION_MESSAGE);
            try {
                colunas = Integer.valueOf(valor);
            } catch (NumberFormatException e) {
                JOptionPane
                    .showMessageDialog(null, "Valor inválido", "Limiarização", JOptionPane.WARNING_MESSAGE);
            }
        } while (colunas < 1 || colunas >= largura);
        do {
            String valor = JOptionPane
                    .showInputDialog(null, "Digite a quantidade de frames para a altura da imagem", "Limiarização", JOptionPane.QUESTION_MESSAGE);
            try {
                linhas = Integer.valueOf(valor);
            } catch (NumberFormatException e) {
                JOptionPane
                    .showMessageDialog(null, "Valor inválido", "Limiarização", JOptionPane.WARNING_MESSAGE);
            }
        } while (linhas < 1 || linhas >= altura);
        
        int larguraFrameLocal = largura / colunas;
        int alturaFrameLocal = altura / linhas;
        
        int x1, x2, y1, y2;
        
        ImagemGUI imagemLimiarizada = new ImagemGUI(largura, altura);
        
        for (int x = 0; x < colunas; x++) {
            for (int y = 0; y < linhas; y++) {
                x1 = x * larguraFrameLocal;
                y1 = y * alturaFrameLocal;
                x2 = x1 + larguraFrameLocal;
                y2 = y1 + alturaFrameLocal;
                limiarizar(imagem, imagemLimiarizada, x1, x2, y1, y2);
            }
        }
        adicionarImagem(imagemLimiarizada);
    }//GEN-LAST:event_LimiarizacaoLocalAutomaticaActionPerformed

    //*******************************************
    /**
     * Adiciona uma janela de imagem ao painel de desktop.
     *
     * @param imagem imagem que deve ser exibida dentro da janela.
     */
    public void adicionarImagem(ImagemGUI imagem) {
        // Cria uma janela interna para a imagem.
        JanelaImagem janelaImagem = new JanelaImagem(imagem);
        // Adiciona a janela, a exibe e seleciona.
        desPanDesktop.add(janelaImagem);
        janelaImagem.setVisible(true);
        try {
            janelaImagem.setSelected(true);
        } catch (PropertyVetoException erro) {
            erro.printStackTrace();
        }
        desPanDesktop.repaint();
    }

    /**
     * Retorna a imagem atualmente selecionada na interface gráfica.
     *
     * @return A imagem atualmente seleciona ou null, caso nenhuma imagem esteja
     * selecionada.
     */
    public ImagemGUI getImagemSelecionada() {
        // Recupera a janela atualmente selecionada.
        JanelaImagem janelaSelecionada = (JanelaImagem) desPanDesktop.getSelectedFrame();
        // Se nenhuma janela estiver selecionada, retorna null.
        if (janelaSelecionada == null) {
            return null;
        }
        // Caso contrário, retorna a imagem da janela.
        return janelaSelecionada.getImagem();
    }

    /**
     * Abre uma janela de seleção de imagens e retorna as imagens selecionadas.
     *
     * @param numeroMinimoImagens Número mínimo de imagens que devem ser
     * selecionadas.
     * @return Uma array com as imagens selecionadas ou null caso nenhuma tenha
     * sido selecionada.
     */
    public ImagemGUI[] selecionarImagens(int numeroMinimoImagens) {
        // Se não tiver nenhuma imagem aberta, avisa o usuário.
        if (desPanDesktop.getAllFrames().length == 0) {
            JOptionPane.showMessageDialog(this, "Não existem imagens abertas.");
        }

        // Recupera as imagens abertas.
        List<ImagemGUI> imagens = new ArrayList<>();
        for (JInternalFrame frame : desPanDesktop.getAllFrames()) {
            JanelaImagem janela = (JanelaImagem) frame;
            imagens.add(janela.getImagem());
        }

        ImagemGUI[] todasImagens = new ImagemGUI[imagens.size()];
        imagens.toArray(todasImagens);
        SelecionadorImagens selecionador = new SelecionadorImagens(this, true, todasImagens, numeroMinimoImagens);
        selecionador.setVisible(true);
        return selecionador.getImagensSelecionadas();
    }

    //*******************************************
    // Programa principal.
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                Desktop desktop = new Desktop();
                desktop.setExtendedState(JFrame.MAXIMIZED_BOTH);
                desktop.setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem BT709Grayscale;
    private javax.swing.JMenuItem ComponenteB;
    private javax.swing.JMenuItem ComponenteG;
    private javax.swing.JMenuItem ComponenteR;
    private javax.swing.JMenu ConversaoDeCores;
    private javax.swing.JMenuItem Exibir;
    private javax.swing.JMenu Histograma;
    private javax.swing.JMenuItem LimiarizacaoGlobalAutomatica;
    private javax.swing.JMenuItem LimiarizacaoLocalAutomatica;
    private javax.swing.JMenuItem MonocromatizarPorBrilho;
    private javax.swing.JMenu MonocromatizarPorComponente;
    private javax.swing.JMenu MonocromatizarPorLuminosidade;
    private javax.swing.JMenuItem MonocromatizarPorMedia;
    private javax.swing.JMenuItem MostrarBordas;
    private javax.swing.JMenuItem RMYGrayscale;
    private javax.swing.JMenuItem RemoverRuido;
    private javax.swing.JMenuItem YGrayscale;
    private javax.swing.JMenuItem blur;
    private javax.swing.JDesktopPane desPanDesktop;
    private javax.swing.JMenuItem equalizar;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenu limiarizacao;
    private javax.swing.JMenuItem limiarizacaoManual;
    private javax.swing.JMenu menArquivo;
    private javax.swing.JMenuBar menBarMenuPrincipal;
    private javax.swing.JMenu menExemplo;
    private javax.swing.JMenuItem menIteAbrir;
    private javax.swing.JMenuItem menIteDivisao;
    private javax.swing.JMenuItem menIteExemplo1;
    private javax.swing.JMenuItem menIteExemplo2;
    private javax.swing.JMenuItem menIteMultiplicacao;
    private javax.swing.JMenuItem menIteSair;
    private javax.swing.JMenuItem menIteSalvarComo;
    private javax.swing.JMenuItem menIteSoma;
    private javax.swing.JMenuItem menIteSubtracao;
    private javax.swing.JMenu menOperacoesAritmeticas;
    private javax.swing.JPopupMenu.Separator sepArquivo1;
    // End of variables declaration//GEN-END:variables

    private int[][][] realizarOperacao(ImagemGUI[] imagens, Operacao operacao, boolean inicializarMatrizComPrimeiraImagem) {
        
        int largura = Arrays.stream(imagens).mapToInt(i -> i.getLargura()).max().getAsInt();
        int altura = Arrays.stream(imagens).mapToInt(i -> i.getAltura()).max().getAsInt();
        int[][][][] arrayImagens = new int[imagens.length][3][largura][altura];
        for (int i = 0; i < imagens.length; i++){
            arrayImagens[i] = imagens[i].getMatrizesRGB();
        }
        return realizarOperacao(arrayImagens, operacao, inicializarMatrizComPrimeiraImagem);
    }
    
    private int[][][] realizarOperacao(int[][][][] imagens, Operacao operacao, boolean inicializarMatrizComPrimeiraImagem) {
        // Encontrar o tamanho da maior imagem dentre as imagens.
        int largura = Arrays.stream(imagens).mapToInt(i -> i[0].length).max().getAsInt();
        int altura = Arrays.stream(imagens).mapToInt(i -> i[0].length).max().getAsInt();

        // Cria uma matriz para armazenar o resultado das operações.
        int[][][] resultadoOperacao = new int[3][largura][altura];

        int maiorR = Integer.MIN_VALUE;
        int menorR = Integer.MAX_VALUE;
        int maiorG = Integer.MIN_VALUE;
        int menorG = Integer.MAX_VALUE;
        int maiorB = Integer.MIN_VALUE;
        int menorB = Integer.MAX_VALUE;

        int i = 0;
        if (inicializarMatrizComPrimeiraImagem) {
            i = 1;
            for (int x = 0; x < imagens[0][0].length; x++) {
                for (int y = 0; y < imagens[0][0][0].length; y++) {
                    // Somar os valores dos pixels e armazenar na matriz.
                    resultadoOperacao[R][x][y] = imagens[0][R][x][y];
                    resultadoOperacao[G][x][y] = imagens[0][G][x][y];
                    resultadoOperacao[B][x][y] = imagens[0][B][x][y];
                }
            }
        }

        // Passar por todas as imagens.
        for (int j = i; j < imagens.length; j++) {
            int[][][] imagem = imagens[j];
            // Passar por todos os pixels.
            for (int x = 0; x < imagem[0].length; x++) {
                for (int y = 0; y < imagem[0][0].length; y++) {
                    // Somar os valores dos pixels e armazenar na matriz.
                    resultadoOperacao[R][x][y] = (int) operacao.realizar(resultadoOperacao[R][x][y], imagem[R][x][y]);
                    resultadoOperacao[G][x][y] = (int) operacao.realizar(resultadoOperacao[G][x][y], imagem[G][x][y]);
                    resultadoOperacao[B][x][y] = (int) operacao.realizar(resultadoOperacao[B][x][y], imagem[B][x][y]);

                    // Encontra os maiores e menores valores da cada matriz.
                    if (resultadoOperacao[R][x][y] > maiorR) {
                        maiorR = resultadoOperacao[R][x][y];
                    } else if (resultadoOperacao[R][x][y] < menorR) {
                        menorR = resultadoOperacao[R][x][y];
                    }
                    if (resultadoOperacao[G][x][y] > maiorG) {
                        maiorG = resultadoOperacao[G][x][y];
                    } else if (resultadoOperacao[G][x][y] < menorG) {
                        menorG = resultadoOperacao[G][x][y];
                    }
                    if (resultadoOperacao[B][x][y] > maiorB) {
                        maiorB = resultadoOperacao[B][x][y];
                    } else if (resultadoOperacao[B][x][y] < menorB) {
                        menorB = resultadoOperacao[B][x][y];
                    }
                }
            }
        }

        return resultadoOperacao;
//        // Cria uma nova imagem baseando-se na atual.
//        ImagemGUI truncada = new ImagemGUI("Imagem resultante da operacao com truncamento", largura, altura);
//        ImagemGUI normalizada = new ImagemGUI("Imagem resultante da operacao com normalização", largura, altura);
//
//        double fatorR = 255d / (maiorR - menorR);
//        double fatorG = 255d / (maiorG - menorG);
//        double fatorB = 255d / (maiorB - menorB);
//        
//        // Truncar e normalizar.
//        for (int x = 0; x < largura; x++) {
//            for (int y = 0; y < altura; y++) {
//                int r, g, b;
//                r = resultadoOperacaoR[y][x];
//                g = resultadoOperacaoG[y][x];
//                b = resultadoOperacaoB[y][x];
//
//                if (r > 255) {
//                    r = 255;
//                } else if (r < 0) {
//                    r = 0;
//                }
//
//                if (g > 255) {
//                    g = 255;
//                } else if (g < 0) {
//                    g = 0;
//                }
//
//                if (b > 255) {
//                    b = 255;
//                } else if (b < 0) {
//                    b = 0;
//                }
//
//                truncada.setRGB(x, y, r, g, b);
//
//                r = (int) (fatorR * (resultadoOperacaoR[y][x] - menorR));
//                g = (int) (fatorG * (resultadoOperacaoG[y][x] - menorG));
//                b = (int) (fatorB * (resultadoOperacaoB[y][x] - menorB));
//
//                normalizada.setRGB(x, y, r, g, b);
//            }
//        }
//
//        // Pintar o resultado na imagem final.
//        adicionarImagem(truncada);
//        adicionarImagem(normalizada);
    }

    private int getR(ImagemGUI imagem, int x, int y) {
        if (x >= imagem.getLargura() || y >= imagem.getAltura()) {
            return 0;
        }
        return imagem.getR(x, y);
    }

    private int getG(ImagemGUI imagem, int x, int y) {
        if (x >= imagem.getLargura() || y >= imagem.getAltura()) {
            return 0;
        }
        return imagem.getG(x, y);
    }

    private int getB(ImagemGUI imagem, int x, int y) {
        if (x >= imagem.getLargura() || y >= imagem.getAltura()) {
            return 0;
        }
        return imagem.getB(x, y);
    }

    public int[] encontrarCorMaisFrequente(ImagemGUI imagem) {
        int[] quantidadeDePixelsPorCorR = new int[256];
        int[] quantidadeDePixelsPorCorG = new int[256];
        int[] quantidadeDePixelsPorCorB = new int[256];

        for (int x = 0; x < imagem.getLargura(); x++) {
            for (int y = 0; y < imagem.getAltura(); y++) {

                quantidadeDePixelsPorCorR[imagem.getR(x, y)]++;
                quantidadeDePixelsPorCorG[imagem.getG(x, y)]++;
                quantidadeDePixelsPorCorB[imagem.getB(x, y)]++;

            }
        }

        int maisFrequenteR = 0;
        int quantosR = 0;
        int maisFrequenteG = 0;
        int quantosG = 0;
        int maisFrequenteB = 0;
        int quantosB = 0;
        for (int i = 0; i < quantidadeDePixelsPorCorR.length; i++) {
            if (quantidadeDePixelsPorCorR[i] > quantosR) {
                quantosR = quantidadeDePixelsPorCorR[i];
                maisFrequenteR = i;
            }
            if (quantidadeDePixelsPorCorG[i] > quantosG) {
                quantosG = quantidadeDePixelsPorCorG[i];
                maisFrequenteG = i;
            }
            if (quantidadeDePixelsPorCorB[i] > quantosB) {
                quantosB = quantidadeDePixelsPorCorB[i];
                maisFrequenteB = i;
            }
        }
        return new int[]{maisFrequenteR, maisFrequenteG, maisFrequenteB};
    }

    private int[][][] aplicarKernel(int[][] kernel, ImagemGUI imagem, Filtro filtro) {
        
        int larguraImagem = imagem.getLargura();
        int alturaImagem = imagem.getAltura();
        
        int larguraKernel = kernel.length;
        int alturaKernel = kernel[0].length;
        
        int movimentoLargura = larguraKernel / 2;
        int movimentoAltura = alturaKernel / 2;
        
        int y, x,
            primeiroX, primeiroY,
            ultimoX, ultimoY,
            indice;
        
        int[][][] matrizesCores = new int[3][larguraImagem][alturaImagem];
        int[] retornoFiltro;
        
        for ( y = movimentoAltura; y < alturaImagem - movimentoAltura; y++ ){
            for ( x = movimentoLargura; x < larguraImagem - movimentoLargura; x++ ){
                // primeiro e ultimo indice y da imagem sob o kernel
                primeiroY = (y - movimentoAltura);
                ultimoY = (y + movimentoAltura);
                
                // primeiro e ultimo indice x da imagem sob o kernel
                primeiroX = (x - movimentoLargura);
                ultimoX = (x + movimentoLargura);
                
                retornoFiltro = filtro.filtrar(imagem, kernel, primeiroY, ultimoY, primeiroX, ultimoX);
                
                for (indice = R; indice <= B; indice++){
                    matrizesCores[indice][x][y] = retornoFiltro[indice];
                }
            }
        }
        return matrizesCores;
    }

    private int[][][] aplicarKernelBorda(int[][] kernel, ImagemGUI imagem, Filtro filtro) {
        
        int larguraImagem = imagem.getLargura();
        int alturaImagem = imagem.getAltura();
        
        int larguraKernel = kernel.length;
        int alturaKernel = kernel[0].length;
        
        int movimentoLargura = larguraKernel / 2;
        int movimentoAltura = alturaKernel / 2;
        
        int y, x,
            primeiroX, primeiroY,
            ultimoX, ultimoY,
            indice;
        
        int[][][] matrizesCores = new int[3][larguraImagem][alturaImagem];
        int[] retornoFiltro;
        
        for ( y = 0; y < alturaImagem; y++ ){
            for ( x = 0; x < larguraImagem; x++ ){
                // primeiro e ultimo indice y da imagem sob o kernel
                primeiroY = (y - movimentoAltura) < 0 ? 0 : y - movimentoAltura;
                ultimoY = (y + movimentoAltura) > alturaImagem -1 ? alturaImagem -1 : y + movimentoAltura;
                
                // primeiro e ultimo indice x da imagem sob o kernel
                primeiroX = (x - movimentoLargura) < 0 ? 0 : x - movimentoLargura;
                ultimoX = (x + movimentoLargura) > larguraImagem -1 ? larguraImagem -1 : x + movimentoLargura;
                
                retornoFiltro = filtro.filtrar(imagem, kernel, primeiroY, ultimoY, primeiroX, ultimoX);
                
                for (indice = R; indice <= B; indice++){
                    matrizesCores[indice][x][y] = retornoFiltro[indice];
                }
            }
        }
         return matrizesCores;
    }

    private ImagemGUI normalizar(int[][][] cores) {
        
        int largura = cores[0].length;
        int altura = cores[0][0].length;
        
        // Cria base para nova imagem a partir da imagem original
        ImagemGUI normalizada = new ImagemGUI("Imagem resultante", largura, altura);
        
        // Encontra os maiores e menores valores das matrizes.
        int maiorR = Integer.MIN_VALUE;
        int menorR = Integer.MAX_VALUE;
        int maiorG = Integer.MIN_VALUE;
        int menorG = Integer.MAX_VALUE;
        int maiorB = Integer.MIN_VALUE;
        int menorB = Integer.MAX_VALUE;
        for (int x = 0; x < largura; x++) {
            for (int y = 0; y < altura; y++) {
                if (cores[R][x][y] > maiorR) {
                    maiorR = cores[R][x][y];
                } else if (cores[R][x][y] < menorR) {
                    menorR = cores[R][x][y];
                }
                if (cores[G][x][y] > maiorG) {
                    maiorG = cores[G][x][y];
                } else if (cores[G][x][y] < menorG) {
                    menorG = cores[G][x][y];
                }
                if (cores[B][x][y] > maiorB) {
                    maiorB = cores[B][x][y];
                } else if (cores[B][x][y] < menorB) {
                    menorB = cores[B][x][y];
                }
            }
        }

        double fatorR = 255d / (maiorR - menorR);
        double fatorG = 255d / (maiorG - menorG);
        double fatorB = 255d / (maiorB - menorB);
        
        int r, g, b;

        // normalizar.
        for (int x = 0; x < largura; x++) {
            for (int y = 0; y < altura; y++) {
                
                r = cores[R][x][y];
                g = cores[G][x][y];
                b = cores[B][x][y];

                r = (int) (fatorR * (r - menorR));
                g = (int) (fatorG * (g - menorG));
                b = (int) (fatorB * (b - menorB));

                normalizada.setRGB(x, y, r, g, b);
            }
        }

        return normalizada;
    }

    private ImagemGUI truncar ( int[][][] cores ){
        
        int largura = cores[0].length;
        int altura = cores[0][0].length;
        
        int r, g, b;
        
        // Cria base para nova imagem a partir da imagem original
        ImagemGUI truncada = new ImagemGUI("Imagem resultante", largura, altura);
        
        for (int x = 0; x < largura; x++) {
            for (int y = 0; y < altura; y++) {
                
                r = cores[R][x][y];
                g = cores[G][x][y];
                b = cores[B][x][y];
                
                r = Math.min(255, Math.max(0, r));
                g = Math.min(255, Math.max(0, g));
                b = Math.min(255, Math.max(0, b));

                truncada.setRGB(x, y, r, g, b);
            }
        }
        
        return truncada;
    }

    private ImagemGUI monocromatizar(ImagemGUI imagem, Monocromatizador monocromatizador) {
        int largura = imagem.getLargura();
        int altura = imagem.getAltura();
        
        int r, g, b;
        
        // Cria base para nova imagem a partir da imagem original
        ImagemGUI monocromatica = new ImagemGUI("Imagem resultante", largura, altura);
        
        for (int x = 0; x < largura; x++) {
            for (int y = 0; y < altura; y++) {
                
                r = g = b = monocromatizador.aplicar(imagem, y, x);
                monocromatica.setRGB(x, y, r, g, b);
            }
        }
        
        return monocromatica;
    }

    private ImagemGUI gerarHistograma(ImagemGUI imagem) {
        ImagemGUI histograma = new ImagemGUI("Histograma", 510, 200);
        int larguraHistograma = histograma.getLargura();
        int alturaHistograma = histograma.getAltura();
        
        int[][] vetoresHistograma = HistogramaServico.gerarVetores(imagem);

        int maiorValor = HistogramaServico.encontrarMaiorValor(vetoresHistograma[0]);
        float[] vetorProblabilidade = new float[510];
        for (int i = 0; i < vetorProblabilidade.length; i += 2) {
            vetorProblabilidade[i] = (float) vetoresHistograma[0][i/2] / maiorValor * 200;
            vetorProblabilidade[i+1] = (float) vetorProblabilidade[i];
        }
        
        for (int x = 0; x < larguraHistograma; x++) {
            for (int y = 0; y < alturaHistograma; y++) {
                if ((alturaHistograma - y) < vetorProblabilidade[x]){
                    histograma.setGrayScale(x, y, 0);
                } else {
                    histograma.setGrayScale(x, y, 200);
                }
            }
        }
        
        return histograma;
    }

    private ImagemGUI equalizar(ImagemGUI imagem) {
        int largura = imagem.getLargura();
        int altura = imagem.getAltura();
        int r, g, b;
        
        // Cria base para nova imagem a partir da imagem original
        ImagemGUI equalizada = new ImagemGUI("Imagem Equalizada", largura, altura);
        
        float[][] vetoresRelativos = HistogramaServico.gerarVetoresRelativos(imagem);
        
        float[][] vetoresProbabilidadeAcumulada = vetoresRelativos;
        for(int i = 1; i < vetoresProbabilidadeAcumulada[0].length; i++){
            vetoresProbabilidadeAcumulada[0][i] = vetoresProbabilidadeAcumulada[0][i-1]
                    + vetoresRelativos[0][i];
            vetoresProbabilidadeAcumulada[1][i] = vetoresProbabilidadeAcumulada[1][i-1]
                    + vetoresRelativos[1][i];
            vetoresProbabilidadeAcumulada[2][i] = vetoresProbabilidadeAcumulada[2][i-1]
                    + vetoresRelativos[2][i];
        }
        
        for (int y = 0; y < altura; y++) {
            for (int x = 0; x < largura; x++) {
                
                r = (int) (255 * vetoresProbabilidadeAcumulada[0][imagem.getR(x, y)]);
                g = (int) (255 * vetoresProbabilidadeAcumulada[1][imagem.getG(x, y)]);
                b = (int) (255 * vetoresProbabilidadeAcumulada[2][imagem.getB(x, y)]);

                equalizada.setRGB(x, y, r, g, b);
            }
        }
        
        return equalizada;
    }

    private void limiarizar(ImagemGUI imagem, ImagemGUI imagemResultante, int x1, int x2, int y1, int y2) {
        float[] vetorRelativoRegiao = HistogramaServico.gerarVetorRelativo(imagem, x1, x2, y1, y2);
        int tamanhoHistograma = vetorRelativoRegiao.length;
        int limiar = tamanhoHistograma / 2;
        float pesoEsquerda = 0;
        float pesoDireita = 0;
        int verificacoes = 0;
        int minimo = 0;
        int maximo = tamanhoHistograma;
        
        do {
            pesoEsquerda = 0;
            pesoDireita = 0;
            for (int i = minimo; i < maximo; i++){
                if (i <= limiar){
                    pesoEsquerda += vetorRelativoRegiao[i];
                } else {
                    pesoDireita += vetorRelativoRegiao[i];
                }
            }
            if (pesoEsquerda > pesoDireita){
                maximo = limiar;
                limiar = minimo + ((limiar - minimo) / 2);
            } else {
                minimo = limiar;
                limiar = limiar + ((maximo - limiar) / 2);
            }
            verificacoes++;
        }while (verificacoes < 10);
        
        System.out.println("limiar: " + limiar);
        
        limiarizar(imagem, imagemResultante, x1, x2, y1, y2, limiar);
    }

    private void limiarizar(ImagemGUI imagem, ImagemGUI imagemResultante, int x1, int x2, int y1, int y2, int limiar) {
        int r, g, b;
        
        for (int x = x1; x < x2; x++) {
            for (int y = y1; y < y2; y++) {
                if (imagem.getR(x, y) < limiar){
                    r = g = b = 0;
                } else {
                    r = g = b = 255;
                }
                imagemResultante.setRGB(x, y, r, g, b);
            }
        }
    }
}
